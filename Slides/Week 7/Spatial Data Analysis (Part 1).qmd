---
title: "MA22019 - Spatial Data Analysis (Part 1)"
author: "Christian Rohrbeck"
date: "19 March 2025"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, warning=FALSE, message=FALSE}
colorize <- function(x, color="blue") {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color,
      x)
  } else x
}
library(dplyr)
```

## Plan for Today

We start the final chapter on spatial data analysis:

* Types of spatial data

* Visualization of point-referenced data (Section 4.1)

* Problem Class 5

* Inverse Distance Weighting (Section 4.2)

* Comments on Coursework 1

## Motivation 

In many applications we have spatial information:

- Air pollution modelling

- Disease outbreaks

- Ecological studies

- Socioeconomic studies

- Weather data


**`r colorize("How can we use this information in a data analysis?")`**



## Types of Spatial Data I 

In spatial data analysis we consider **three** types of spatial data:


**Point-referenced data**

- Data are observed across a number of fixed sites

- Meteorology and mining are text book examples for this type of data


## Types of Spatial Data II 


**Point-pattern data**

- Spatial locations are random variables

- Often found when analyzing disease outbreaks and in ecological studies



**Lattice / Areal unit data**

- Our sites are fixed areas (countries, counties, etc.)

- Examples include insurance claims and **image data**


# Visualizing point-referenced data

## Motivation 


Let's look at some temperature data for Germany

**`r colorize("-> R Markdown file")`**




Just using ggplot2 does not really provide a useful plot.

**Would a map provide additional information?**


## Shapefiles

One option is to add the boundaries of Germany.

Such data is available via the website <a href="https://gadm.org/">gadm.org</a>.

Let's see how we can add such shapefile data to our plot </br>

**`r colorize("-> R Markdown file")`**

## Projections  


We used latitude and longitude within a Cartesian coordinate system. 

**However**, the earth is not flat!



Converting locations on earth to a two-dimensional representation is called a **projection**.

We can choose a projection using the **coord_sf()** function.

**`r colorize("-> R Markdown file")`**


## Example

```{r, warning=FALSE, message=FALSE, out.width='90%', fig.align='center', echo=FALSE}
library(patchwork)
library(sf)
library(ggplot2)
CANADA   <- read_sf("gadm41_CAN_1.shp")
CANADA   <- st_simplify( CANADA, dTolerance = 5000 )
CANPlot1 <- ggplot( data=CANADA ) + theme_bw() + geom_sf()
CANPlot2 <- CANPlot1 + coord_sf( crs=st_crs(3347) )

NORWAY   <- read_sf("gadm41_NOR_1.shp")
NORWAY   <- st_simplify( NORWAY, dTolerance = 2000 )
NORPlot1 <- ggplot( data=NORWAY ) + theme_bw() + geom_sf()
NORPlot2 <- NORPlot1 + coord_sf( crs=st_crs(3346) )

( CANPlot1 + CANPlot2 ) / ( NORPlot1 + NORPlot2 )
```

## Remarks about projections

- **WGS84 coordinate reference system** is the standard for GPS systems and Google Earth and has **st_crs(4326)**

- The projection may have a influence on how the plot is perceived

- Some projections are better for some parts of the world than for others

- For small areas we usually don't need to consider projections.

- When using projections, we also need to project the points

**`r colorize("-> R Markdown file")`**

## Creating maps with ggspatial


It may be better to place points on a (colourful) map.

This will be achieved by importing OpenStreetMap data using the package **ggspatial()**
  
```{r, message=FALSE, warning=FALSE, echo=TRUE}
library(ggspatial)
library(prettymapr)
```



**How to make it work**

1) Add the function "annotation_map_tile()"

2) Replace **geom_point()** by **geom_spatial_point()**

**`r colorize("-> R Markdown file")`**



# Problem Class 5

## Exercise

Please go to Moodle and download the materials for Problem Class 5.

# Inverse Distance Weighting

## Motivation 

```{r, fig.align='center', out.width='75%', echo=FALSE, warning=FALSE, message=FALSE}
library(ggplot2)
library(sf)
Temperature <- read.csv( "Temperature Germany.csv" )
ggplot( data=Temperature ) + 
  annotation_map_tile( zoom=5 ) + 
  geom_spatial_point( size=3,
              aes(x=longitude, y=latitude, color=max.temp) ) + 
  theme_bw() +
  scale_color_distiller( palette="Reds", trans="reverse" ) +
  labs( x="Longitude", y="Latitude", color="Temperature" )
```

`r colorize("What is the temperature at an unobserved location?")`

## Notation

We introduce some notation to define our approach mathematically:

- $n$ observations $x_1,\ldots,x_n\in\mathbb{R}$

- locations $\mathbf{s}_1,\ldots,\mathbf{s}_n\in\mathbb{R}^2$

- $\mathbf{s}^*$ is the unobserved location for which we want to derive a prediction $x^*$

**`r colorize("How could we use the data and location information to get a prediction?")`**

## Inverse Distance Weighting 


Let $d: \mathbb{R}^2 \times \mathbb{R}^2 \to \mathbb{R}_+$ be a distance metric, such as
\[
d(\mathbf{s}_1, \mathbf{s}_2) = ||\mathbf{s}_1-\mathbf{s}_2||_2= \sqrt{(s_{11}-s_{21})^2 + (s_{12}-s_{22})^2}.
\]



Inverse distance weighting defines
\[
x^* = 
\begin{cases}
\dfrac{\sum_{i=1}^n w(\mathbf{s}_i,\mathbf{s}^*) x_i}{\sum_{i=1}^n, w(\mathbf{s}_i,\mathbf{s}^*)} & \mbox{if}~d(\mathbf{s}^*, \mathbf{s}_i)>0,\\
x_i & \mathrm{if}~d(\mathbf{s}^*, \mathbf{s}_i)=0,
\end{cases}
\]
where $w(\mathbf{s}_i,\mathbf{s}^*) = \left[d(\mathbf{s}_i,\mathbf{s}^*)\right]^{-p}$ and $p>0$ is called the **power parameter**. 



## Effect of the power parameter 


We have to select a suitable value for $p$.

**Example:** Suppose $\mathbf{s}^* = (13.1, 51.0)$ for the German temperature data. 

Let's compare $p=0.5$, $p=2$ and $p=20$.

**`r colorize("-> R Markdown file")`**



It may be useful to create a map of predicted values to:

* Study spatial pattern of the values

* Select a suitable value for $p$



## Remarks

- We only need a reasonable $p$, it does not have to optimal

- The Euclidian distance for $d(\mathbf{s}_1,\mathbf{s}_2)$ is not necessarily the best choice

    + **Example:** We ignored the aspect of altitude in our calculations

- Be careful when making predictions for locations that are not close to at least one location in $\{\mathbf{s}_1, \ldots,\mathbf{s}_n\}$

## Summary

Today we learned that

- Spatial data occurs in several applications

- There are **three** types of spatial data

- We can use shapefiles and maps to visualize the data

- When studying large areas, we have to consider the projection

- Inverse distance weighting may be used for predicting values at unobserved locations

# Coursework 1

## Summary

**Average: 58.7%**

**Office Hour for questions on the coursework:**

* Thursday (tomorrow): 12:30-15:00

* Monday: 9:00-10:15 and 16:00-18:00

**Advice for Coursework 2:** 

* Don't suppress the R code for loading packages

* Make use of R Markdown options to modify the size of plots.

* Clearly describe your approach.

## Reminder - What does it mean to be a data scientist

```{r, echo=F, out.width='55%', fig.width=7, fig.height=7, fig.align='center', warning=FALSE}
library(MASS, quietly = T, warn.conflicts = F)
circle <- function( x, r ){
  z <- seq( 0, 2*pi, length.out = 1000 )
  return( cbind( x[1]+r*cos(z), x[2]+r*sin(z) ) )
}
par(mai=c(0.01,0.01,0.01,0.01))
plot( circle( x = c(0, -sqrt(2) ), r=2 ), xlab="", ylab="",
      xaxt="n", yaxt="n", type='l', xlim=c(-3.1,3.1), 
      ylim=c(-3.4,2.8) )
lines( circle( x = sqrt(2) * c(-cos(pi/6),sin(pi/6)), r=2 ) )
lines( circle( x = sqrt(2) * c(cos(pi/6),sin(pi/6)), r=2 ) )
text(label = c("Mathematics"), x=-2, y=1.1, cex=1.8)
text(label = c("Statistics"), x=-2, y=0.6, cex=1.8)
text(label = c("Computer Science"), x=0, y=-2, cex=1.8)
text(label = c("Application"), x=2, y=1, cex=1.8)
text(label = c("Data"), x=0, y=0.35, cex=2.0, col=2)
text(label = c("Science"), x=0, y=-0.05, cex=2.0, col=2)
```
