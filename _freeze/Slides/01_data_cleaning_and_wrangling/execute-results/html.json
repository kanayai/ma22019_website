{
  "hash": "64cb7f2118119e80614ee22e1a7762de",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Cleaning and Wrangling\"\nsubtitle: \"Lecture\"\ndate: \"5 February 2025\"\n---\n\n\n\n# Data Cleaning\n\n## Converting data into a useable format\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/DataCleaning.jpg){fig-align='center' width=55%}\n:::\n:::\n\n\n<p style=\"color:Blue\">**What do you think is part of data cleaning?**</p>\n\n## Why do we perform data cleaning?\n\nTwo key reasons are:\n\n* Data are not of the correct type and thus incompatible with available R functions \n\n* Uninformative variable names\n  \nWe now explore how the dplyr and lubridate R packages can help us.\n\n  \n## Example - River Flow Data\n  \n\n  \nLet's have a look at the data in \"Bathford River Flow.csv\".\n\n<p style=\"color:Blue\"> **What do we notice?**</p>\n\n\n\n1. The provided variables represent the date and mean river flow\n\n2. Data is not in a nice format\n\n3. No variable names\n\n\n## River Flow Data - Loading the Data \n\n\nWe use the **read.csv()** function to load the data:\n\n::: {.cell}\n\n```{.r .cell-code}\nBathford <- read.csv(\"data/bathford_river_flow.csv\",\n    skip = 20, header = FALSE,\n    colClasses = c(\"character\", \"numeric\", \"NULL\")\n)\n```\n:::\n\n\n\n\nWe use **glimpse()** to check the variable names and data types:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nglimpse(Bathford)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 19,697\nColumns: 2\n$ V1 <chr> \"1969-10-27\", \"1969-10-28\", \"1969-10-29\", \"1969-10-30\", \"1969-10-31…\n$ V2 <dbl> 3.998, 3.958, 4.210, 4.480, 4.205, 3.830, 3.723, 3.986, 4.353, 4.52…\n```\n\n\n:::\n:::\n\n\n\n\n## Converting Variables I \n\nThe loaded data may not have the correct type:\n\n- Numerical data were read as a **character**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nExample1 <- read.csv(\"data/DataCleaningExample1.csv\")\nglimpse(Example1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 8\nColumns: 1\n$ Value <chr> \"1.02\", \"0.98\", \"0.79\", \"M\", \"2.1\", \"15.1\", \"M\", \"4.2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(Example1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n## Converting Variables II\n\nWe use the function **as.numeric()** to convert the type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nExample1$Value <- as.numeric(Example1$Value)\nglimpse(Example1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 8\nColumns: 1\n$ Value <dbl> 1.02, 0.98, 0.79, NA, 2.10, 15.10, NA, 4.20\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(Example1$Value, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.031667\n```\n\n\n:::\n:::\n\n\n## Converting Variables III \n\n-   Binary answers were recorded as \"yes\" or \"no\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponses <- c(\"Y\", \"Y\", \"N\", \"Y\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"Y\")\nresponses <- case_when(responses == \"Y\" ~ 1, responses == \"N\" ~ 0)\nresponses\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 0 1 0 1 0 0 0 1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(responses)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n:::\n\n\n## Converting Variables IV\n\n-    Convert from character to **date**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\ndate_observed <- c(\"01/10/2022\", \"15/10/2023\")\ndate_converted <- as_date(date_observed, format = \"%d/%m/%Y\")\ndate_converted\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2022-10-01\" \"2023-10-15\"\n```\n\n\n:::\n:::\n\n\n## Why do we convert to a date object? \n\n\n\n-   Extraction of month and year from a Date object using **month()** and **year()** respectively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyear(date_converted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2022 2023\n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   Calculate differences between dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_date(\"20/04/2025\", format = \"%d/%m/%Y\") - as_date(\"2025-02-05\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 74 days\n```\n\n\n:::\n:::\n\n\n\n\n\n\n-   Create plot with time being one of the axis.\n\n\n\n\n\n\n\n## River Flow Data - Converting variables \n\n-   We see that the first variable should be of type **date**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBathford$V1 <- as_date(Bathford$V1, format = \"%Y-%m-%d\")\nglimpse(Bathford)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 19,697\nColumns: 2\n$ V1 <date> 1969-10-27, 1969-10-28, 1969-10-29, 1969-10-30, 1969-10-31, 1969-1…\n$ V2 <dbl> 3.998, 3.958, 4.210, 4.480, 4.205, 3.830, 3.723, 3.986, 4.353, 4.52…\n```\n\n\n:::\n:::\n\n\n\n## Renaming Variables \n\n\n\nUninformative variable names can cause problems!\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/Dilbert.gif){fig-align='center' width=90%}\n:::\n:::\n\n\n## River Flow Data - Renaming variables\n\nThe **rename()** function in the dplyr package can be used to change variable names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBathford <- rename(Bathford, Date = V1, RiverFlow = V2)\nglimpse(Bathford)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 19,697\nColumns: 2\n$ Date      <date> 1969-10-27, 1969-10-28, 1969-10-29, 1969-10-30, 1969-10-31,…\n$ RiverFlow <dbl> 3.998, 3.958, 4.210, 4.480, 4.205, 3.830, 3.723, 3.986, 4.35…\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## River Flow Data - Plotting the data\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(Bathford$Date, Bathford$RiverFlow,\n    type = \"l\",\n    xlab = \"Date\", ylab = \"River Flow\"\n)\n```\n\n::: {.cell-output-display}\n![](01_data_cleaning_and_wrangling_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=65%}\n:::\n:::\n\n\n\n\n## Exercise\n\n**Which conclusions should we report when asked to comment on the frequency of river flow levels above 100m$^3$/s and the magnitude of river flow levels?**\n\n1) Recorded river flow levels were as high as approximately 250m$^3$/s.\n\n2) The data exhibits seasonality, with river flow levels being higher in winter than in summer.\n\n3) The data covers the years 1969 to 2023.\n\n4) There is at least one day with river flow levels exceeding 100m$^3$/s for most years.\n\n\n# Data Wrangling for a single data frame\n\n## Motivation\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/pipeline2.jpg){fig-align='center' width=100%}\n:::\n:::\n\n\n## Why is data wrangling useful? \n\n\n**We want to use the available data to address a research question.**\n\n\n\nWhen working with large data sets, we usually have to:\n\n* Identify and extract the relevant data points / variables \n\n* Create new variables from the collected data\n\n* Summarize / sort the data\n\n**Data wrangling** refers to restructuring the raw data to aid with addressing specific research questions.\n\n\n\n## The dplyr R package\n\nWe will now introduce several functions provided by the dplyr package for data wrangling:\n\n* **filter()** and **select()**\n\n* **mutate()**\n\n* **summarize()** and **group_by()**\n\n* **arrange()** \n\n* the pipe **%>%**\n\n## Summary\n\n\nWe covered some general aims of the data cleaning process:\n\n-   Converting expressions to a useful format using as.numeric(), case_when() and as_date()\n\n-   Give variables informative names using rename()\n\n\n\n\nWe also explored how to use the dplyr package to:\n\n-   Extract the relevant observations and variables\n\n-   Add new variables to a data frame\n\n-   Summarize and sort the data\n\n",
    "supporting": [
      "01_data_cleaning_and_wrangling_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}