[
  {
    "objectID": "lecture_notes/02-DataVisualization.html",
    "href": "lecture_notes/02-DataVisualization.html",
    "title": "Data Visualization",
    "section": "",
    "text": "In Chapter 1 we explored how to restructure a data set and extract summaries. In this chapter we will focus on data visualization, i.e., the creation and interpretation of plots that give us further insight into the data. Data visualization is not just important for data exploration, but also for presenting and communicating results.\nThere are two very important aspects we need to keep in mind:\n\nEffective data visualization is more about clear communication than creating impressive plots. Your analysis may be excellent, but it won’t attract any attention if you cannot convey your results effectively.\nPlots support our arguments and/or highlight the reason for our conclusion. As such we should interpret plots in the context of the research question and not just provide a plot as the answer.\n\nWe start by introducing a general framework for describing data graphics in Section 2.1. Sections 2.2 and 2.3 then demonstrate how to use the R package ggplot2 for data visualization. Finally, some further aspects are considered in Section 2.4.\nRemark: The methods and techniques considered in this chapter cover general aspects of data visualization. Specific methods for illustrating text and spatial data are left to the next chapters.\nImportant: Data visualization is to some degree subjective, because there is often not just one way to visualize the data. However, you should follow the principles outlined in this chapter, and your conclusions need to be supported by your plot. Do not claim something that is not clearly visible in your output!\n\nBefore starting to create plots in R, we establish a framework to analyze plots in terms of four basic elements: visual cues, coordinate system, scale and context. Understanding these elements will help us with producing our own plots later.\n\nVisual cues are graphical elements that draw the audience to the aspects we want them to focus on. The book “Data points: Visualization that means something” by Nathan Yau (link provided on Moodle) lists nine distinct visual cues to encode a category or quantity:\n\nPosition (quantity) - relation to other things\nLength (quantity) - size in one dimension\nAngle (quantity) - width of angle may, for instance, represent proportions (pie chart)\nDirection (quantity) - slope of line\nShape (category) - which observations are in the same group\nArea (quantity) - size in two dimensions\nVolume (quantity) - size in three dimensions\nShade (quantity or category) - shade in comparison to others, or grouping\nColour (quantity or category) - colour in comparison to others, or grouping\n\nResearch has shown that our ability to perceive differences in magnitude descends in this order. One of many publications supporting this argument is “Graphical perception: Theory, experimentation, and application to the development of graphical methods.”, which you can find on Moodle.\nImportant: One crucial conclusion is that we should not rely too much on colour. Many people have colour deficiencies, which makes it very hard for them to distinguish certain colours. Consequently, before using colour, we should consider whether we could use shapes or shades instead.\nRemark: In this course we focus on creating 2D graphics. While 3D plots and animations allow us to visualize a larger number of variables (and you may think they look more impressive), I would avoid using such plots except for a very limited number of cases. That’s because it is often difficult to see the exact positions of the points.\n\nThe data set “Freediving Records.csv” provides information on the progression of the world record in multiple disciplines for men and women. We will focus on the discipline “dynamic apnea with fins (DYN)” and visualize how the world records for men and women have progressed over time:\n\n\n\n\nDevelopment of the world record in dynamic apnea with fins (DYN) for men and women between 1993 and 2020.\n\n\n\nWe can identify that the following visual cues have been used:\n\nShape and colour indicate whether the observations refer to the world record for men or women. Note, there is no issue with using multiple cues for the same information.\nLength of line is used to convey two pieces of information: (i) the length of the line in horizontal direction indicates the time it took until the world record was broken, and (ii) the length of the line in vertical direction represents the magnitude of improvement.\nPosition is used to compare the world records for men and women (both lines are provided in the plot).\nShape is used to highlight the times when a world record was broken - this makes it is easy to count the number of times the record was broken. Without this visual cue, such information would be much harder to extract from the plot.\n\nChoosing a suitable coordinate system is critical to present the data accurately and in a meaningful way. The three most common coordinate systems used in data science are\n\nCartesian:\n\nOur familiar (\\(x,y\\))-rectangular coordinate system with two perpendicular axes.\n\nPolar:\n\nPoints are identified by their radius \\(r\\) (distance from the origin) and angle \\(\\theta\\). A point (\\(x,y\\)) in Cartesian coordinates can be transformed to polar coordinates using the relationship [ (x,y) = (r, r), r=. ]\n\nGeographical:\n\nIn the chapter on spatial data analysis, we will work with points located across the earth, with their positions being defined by longitude and latitude.\n\n\nThere are two common cases when we may want to consider polar coordinates:\n\nPie charts\nVariables which naturally lie on a circle, such as wind direction.\n\nTip: Since Position and Length are better visual cues than Angle, we should prefer Cartesian coordinates to polar coordinates. For instance, before using pie charts, consider whether the same information can be displayed effectively in a bar plot. However, we will see some examples where polar coordinates may be considered the better choice.\n\nHourly weather data was collected for Bela Vista, Brazil, for 2017 and 2018. Suppose we were asked to explore the distribution of wind direction and the relation between wind direction and speed of wind gusts.\nTo analyse the distribution of wind direction, we may create a histogram of the collected data. Let’s compare the histograms obtained for the Cartesian and polar coordinate systems (both display frequency):\n\n\n\n\nFrequency of wind direction for Bela Vista, Brazil, in 2017 and 2018 displayed using Cartesian coordinates (left) and polar coordinates (right).\n\n\n\nBoth plots, Cartesian (left) and polar (right), show that the wind predominately comes from a north-easterly direction. The right plot is a tick nicer, because it better handles that \\(0^{\\circ}=360^{\\circ}\\) in terms of wind direction, which is recorded as an angle.\nLet’s turn to analyzing the relation between wind direction and speed of wind gusts. For this we create plots which map wind direction against the speed of the wind gusts, again using different coordinate systems:\n\n\n\n\nWind direction versus speed of wind gust for Bela Vista in 2017 and 2018 displayed using Cartesian coordinates (left) and polar coordinates (right).\n\n\n\nWhat can we conclude about the relation between wind direction and speed of wind gusts?\nI personally prefer the left plot because it indicates the difference in frequency of wind directions. The right plot (using polar coordinates) does not provide this information and it seems almost as if wind direction is uniformly distributed - so we would need the histogram in Figure @ref(fig:BVWind1) to correctly interpret the plot.\n\nThe concepts of scale and context refer to the choice of axes and the labeling of the data graphic respectively.\n\nScales allow us to translate values into visual cues by influencing, for instance, the distance (length) between points in a scatter plot. When choosing scales, we have to consider how the displayed distances translate into meaningful differences. Each coordinate axis can have its own scale, and we have three different choices:\nNumerical: Numeric quantities, such as speed, age, etc., are commonly set on a linear, logarithmic or percentage scale.\nCategorical: Categorical variables may have no ordering (political parties), or be ordinal (restaurant ratings). Ordinal variables differ from numeric quantities in that distances are unknown (or not meaningful). For instance, a first class degree is better than a 2.1, but what does this mean in terms of distance?\nTime: While being a numeric quantity, time has some special properties: 1) it can be demarcated by year, month,.. and 2) it can be considered periodical. This second aspect can be highlighted using polar coordinates as seen in Section 2.1.4.\n\nData graphics are provided to aid the reader/viewer with making meaningful comparisons. Context can be added in the form of titles, subtitles and axis labels that explain what is being shown, including the scales and units. It sometimes also helps to include reference points or lines. While we should avoid cluttering or providing excessive annotations, it is necessary to provide proper context.\n\nThe following two plots both illustrate the relation between body weight and brain weight for several mammals, but they use different scales:\n\n\n\n\nBody weight vs brain weight for 62 mammals on linear scale (left) and logarithmic scale (right).\n\n\n\nWe make two observations:\n\nLinear scales were used in the left plot, while logarithmic scales were used in the right plot - this context was provided via the title.\nThe right plot is more informative as it shows a linear relationship between body and brain weight on logarithmic scale. This aspect is not clear in the left plot, and a viewer may focus on the three mammals with the highest brain weight as they appear to be quite different from the rest.\n\nAfter outlining the different elements of a plot in the previous section, we now explore how we can create informative plots using the ggplot2 R package\n\nlibrary( ggplot2 )\n\nWe will introduce and utilize a wide range of plots to analyze historical weather data for five Australian cities. The data is provided on Moodle as “WeatherAustralia.csv” and we start by loading the data and looking at the first few entries:\n\nAUS &lt;- read.csv(\"data/weatheraustralia.csv\" )\nslice_head( AUS, n=5 )\n\n        Date Location MinTemp MaxTemp Rainfall WindGustSpeed\n1 01/01/2009   Sydney    17.7    35.1        0            72\n2 02/01/2009   Sydney    18.5    23.0        0            63\n3 03/01/2009   Sydney    16.9    23.2        0            NA\n4 04/01/2009   Sydney    18.7    27.1        0            65\n5 05/01/2009   Sydney    20.2    31.6        0            63\n\n\nWe see that the data provide daily information on minimum and maximum temperature, amount of rainfall and wind speed. Further, the data also include some missing values, as highlighted by the \\(\\mathrm{\\texttt{NA}}\\) entries.\nIn the following, we perform a data exploration which includes the creation and interpretation of multiple plots. At the end of the analysis, you will be familiar with the general functionality of the ggplot2 package. Further types of plots are listed on the ggplot2 cheat sheet (provided on Moodle). I would advise you to try creating some of them for practice, as they may be useful.\nImportant: In this section we focus on the different types of plots and visual cues. The other elements described in Section 2.1, coordinate system, scale and context, will be considered in Section 2.3.\n\nThe first step is to call the function ggplot() and we usually specify the following inputs:\n\nThe name of the data frame that contains the data we want to plot\nThe names of the variables which specify the axes. This is done using the function aes(), which refers to aesthetics (we will see this very often).\n\nSuppose we want to create a scatter plot of minimum against maximum temperature for the five Australian cities. To initialize the plot, we specify\n\nPlotAUS &lt;- ggplot( AUS, aes( x=MinTemp, y=MaxTemp ) )\n\nHowever, if we call PlotAUS in R, we will see a Cartesian coordinate system, but no points. This is because the coordinate system and visual cues are specified using separate functions in ggplot2. We will consider in the next subsection how to add points as an additional layer.\nRemark: While it is important to use meaningful variable names when programming, I usually make an exception when using ggplot2. For instance, instead of PlotAUS, we could also call it g (for graphic) - I will later use this for brevity.\n\nThe function geom_point() adds the points to the coordinate system created by ggplot(). Returning to the Australian weather data, we generate the scatter plot of daily minimum and maximum temperature using\n\nPlotAUS + geom_point()\n\n\n\nMinimum versus maximum observed daily temperature for five Australian cities between 2008 and 2017.\n\n\n\nWe observe a positive correlation between minimum and maximum daily temperature. However, this plot does not highlight that the data are coming from five different cities. In other words, the plot does not allow us to explore differences between the cities.\nOne possible solution is to use the visual cues shape and colour to indicate to which city a data point belongs. Specifically, we specify via aes() that the variable Location should be used to determine the shape and colour of the points created by the geom_point() function:\n\nPlotAUS + geom_point( aes( shape=Location, color=Location ) )\n\n\n\nMinimum versus maximum observed daily temperature for five Australian cities between 2008 and 2017, with the city being highlighted using the visual cues of shape and colour.\n\n\n\nRemark: If we wanted to use shade, we would have specified \\(\\mathrm{\\texttt{aes( alpha=Location )}}\\).\nWhile our plot now makes clear that the data come from different cities, it is still very cluttered. This makes it hard to draw conclusions on differences between the five Australian cities. Luckily, there is a better option available, which we consider next.\n\nInstead of creating a single plot which contains all points, it seems a nice idea to have a separate plot for each city. In other words, we want to split the data using the variable Location and create one plot per subset.\nThis type of plot is called a facet plot and it provides a simple and effective way to display the data for the separate levels of a categorical variable.\nTo create the facet plot, we use the function facet_wrap() and change the axes labels using the labs() function:\n\nPlotAUS + geom_point() +\n  facet_wrap( ~Location ) +\n  labs( x=\"Minimum daily temperature\", y=\"Maximum daily temperature\" )\n\n\n\nPlots of minimum versus maximum daily temperature between 2008 and 2017 for five Australian cities.\n\n\n\nOur plot now reveals that Darwin is quite different from the other four cities in terms of the distribution of minimum and maximum daily temperature, in particular, in terms of the range of values.\nWhat may be the reason for this difference? What else can we conclude?\n\nAs for the river flow data in Section [1.1.4][Example: Loading and cleaning NRFA river flow data], we may want to explore how a variable changes over time for one of the five cities.\nScatter plots are often not the right choice for such a task, because it’s hard to see patterns in the data. Instead we create a line plot, where the length of the line connecting consecutive dates illustrates the magnitude of change in the values of the variable.\nLet’s see how we can create a line plot for daily maximum temperature over time for Darwin. We start by converting the variable Date in the data frame to the correct type,\n\nAUS &lt;- AUS %&gt;% mutate( Date = as_date( Date, format=\"%d/%m/%Y\" ) )\n\nThe next step is to extract the subset of observations for Darwin, which we store in a separate data frame called Darwin:\n\nDarwin &lt;- filter( AUS, Location == \"Darwin\" )\n\nA line plot is then created by using the geom_line() function, again by first defining the axes in the ggplot() function:\n\nggplot( Darwin, aes( x=Date, y=MaxTemp ) ) + geom_line() + \n  labs( x=\"Date\", y=\"Maximum daily temperature\" )\n\n\n\nTime series plot of daily maximum temperature for Darwin between 2008 and 2017.\n\n\n\nTo create such a (time series) plot for all five cities, we again use facet_wrap(), and we use colour and shape (line type) to highlight the different cities:\n\nggplot( AUS, aes( x=Date, y=MaxTemp ) ) + facet_wrap( ~Location ) + \n  geom_line( aes( color=Location, linetype=Location ) ) + \n  labs( x=\"Date\", y=\"Maximum daily temperature\" )\n\n\n\nTime series plot of daily maximum temperature for five Australian cities between 2008 and 2017.\n\n\n\nThe gap in the plot for Melbourne is due to the data being missing for this time period. One conclusion we draw from the plot is that the maximum daily temperature is less varied for Darwin than the other cities, which exhibit a clear seasonal pattern.\nRemark 1: To draw steps as in Section 2.1.2, we would use geom_step() instead of geom_line().\nRemark 2: The use of colour and shape in Figure @ref(fig:DateTempFacet) is not really necessary. We just did it do illustrate that visual cues can be used together with facet_wrap().\n\nWe now want to investigate the distribution of a single variable, such as the speed of the wind gusts in one (or more) of the cities. Histograms and density plots are useful in such cases. You already created histograms in Year 1 Probability & Statistics and we analyzed such a plot in Section 2.1.4. We start by producing a histogram using ggplot2 and then introduce the density plot in more detail.\n\nThe ggplot2 package provides the function geom_histogram() to create a histogram. As for the hist() function you used before, we have to set a suitable number of bins, and this is done using the bins option inside the geom_histogram() function.\nLet’s return to the data for Darwin. To create a histogram for wind speed gusts, we have to call ggplot() and geom_histogram(), but we now only specify the x-axis:\n\nggplot( Darwin, aes( x=WindGustSpeed ) ) + geom_histogram( bins=20 ) + \n  labs( x=\"Speed of wind gust in km/h\", y=\"Count\" )\n\n\n\nHistogram of the speed of wind gusts for Darwin between 2008 and 2017.\n\n\n\nWhat could be a sensible distribution for the speed of wind gusts, based on the histogram?\n\nA density plot is pretty much a smoothed version of the histogram. Given data \\(x_1,\\ldots,x_n\\), we define the estimate \\(\\hat{f}_X(\\cdot)\\) for the probability density function \\(f_X(\\cdot)\\) of the random variable \\(X\\) as \\[\\begin{equation}\n\\hat{f}_X(x) = \\frac{1}{nh}\\sum_{i=1}^{n} K\\left(\\frac{x-x_i}{h}\\right), \\qquad x\\in\\mathbb{R},\n(\\#eq:KDE)\n\\end{equation}\\] where \\(K(\\cdot)\\) is termed the kernel and \\(h\\) is called the bandwidth. The kernel is a non-negative probability density function. One common choice is to set \\(K(\\cdot)\\) as the density of the standard normal distribution, with [ X(x) = {i=1}^{n}{-}. ]\nIn principle, the bandwidth \\(h\\) has to be set by us. If \\(h\\) is too small, the density plot will look very jittered, while a too large \\(h\\) will obscure the underlying data structure. Consequently, care should be taken when setting the bandwidth.\nRemark 1: When generating density plots in R, a suitable value for \\(h\\) is often provided automatically. However, we sometimes have to set the bandwidth manually.\nRemark 2: It is usually sufficient to provide either the histogram or the density plot, because they visualize similar aspects of the data. Note, the histogram should be used for discrete data.\nIn ggplot2, geom_density() is used to create density plots and, as for geom_histogram(), we only specify the x-axis. Let’s use this type of plot to compare the distributions of the speed of wind gusts for Darwin and Adelaide. To aid the comparison, we place the estimates for the two cities in the same plot:\n\nWeatherAD &lt;- filter( AUS, Location %in% c(\"Adelaide\",\"Darwin\") )\nggplot( WeatherAD, aes( x=WindGustSpeed ) ) +\n  geom_density( aes( linetype=Location, color=Location ), size=1.2 ) +\n  labs( x=\"Speed of wind gust in km/h\", y=\"Density\" )\n\n\n\nDensity plots of the speed of wind gusts for Adelaide (solid) and Darwin (dashed) for 2008–2017.\n\n\n\nThe two estimated curves indicate that Adelaide and Darwin differ in the distribution of wind gust speeds. For instance, Adelaide observes wind gust speeds below 30 km/h more often than Darwin.\nRemark 1: The option \\(\\mathrm{\\texttt{size=1.2}}\\) in geom_density() increases the thickness of the line in the plot - you can set size to any positive value, and higher values will give thicker lines. If you wanted to specify the bandwidth \\(h\\) in @ref(eq:KDE), you have the option \\(\\mathrm{\\texttt{bw=..}}\\).\nRemark 2: Density plots can sometimes be misleading because they are a smoothed version of the histogram. Although Adelaide and Darwin appear to have a similar density in Figure @ref(fig:DAWind) when it comes to high wind speeds, the highest value for Adelaide is 86 km/h, while it is 126 km/h for Darwin. Consequently, we should be cautious when drawing conclusions about the distribution tails based on density plots.\n\nBox plots and violin plots are useful for comparing a number of distributions. For instance, we may want to compare the distributions of wind gust speed for the five Australian cities. While we could produce a separate density plot for each city, box and violin plots tend to be a better choice.\nThe two types of plot differ in terms of the information they provide:\n\nBox plots visualize the median, interquartile range (25% and 75% quantile) and outliers.\nViolin plots visualize the density estimate \\(\\hat{f}_X(\\cdot)\\) as defined in Equation @ref(eq:KDE).\n\n\nIn ggplot2, box plots are created using the geom_boxplot() function. Let’s use this type of plot to compare the wind gust speeds across the five cities. We set the x-axis to the categorical variable Location, and the y-axis as speed of wind gust:\n\nggplot( AUS, aes( x=Location, y=WindGustSpeed ) ) + \n  geom_boxplot( aes( fill=Location ) ) + \n  labs( y=\"Speed of wind gust in km/h\" )\n\n\n\nBox plots of the speed of wind gusts for five Australian cities between 2008 and 2017.\n\n\n\nWe can extract a few details about the distributions of the speed of wind gusts for the five cities. For instance, when considering the median, Melbourne and Sydney record the strongest wind gusts, while Adelaide and Perth record the lowest wind gust speeds.\nRemark 1: The option \\(\\mathrm{\\texttt{fill=Location}}\\) gives each box plot a different colour.\nRemark 2: If we wanted a single box plot for a variable, we would only specify one of the axes.\n\nTo conclude our analysis, we compare the distribution of daily wind gust speeds across the five Australian cities using violin plots. This type of plot is generated using the geom_violin() function, and the syntax is the same as for geom_boxplot(). We make two additions compared to Figure @ref(fig:Box) though:\n\nA plot title is set using the labs() function.\nIt’s good practice to order box and violin plots, for instance, based on the median of the different subgroups. This is achieved using the reorder() function.\n\nPutting everything together, the five violin plots are generated using\n\nggplot( AUS, aes( x=reorder(Location, WindGustSpeed, median, na.rm=TRUE), \n                  y=WindGustSpeed ) ) + geom_violin() + \n  labs( x=\"Location\", y=\"Wind gust speed in mph\", \n        title=\"Wind gust speed across five Australian cities\" )\n\n\n\nViolin plots of wind speed across five cities in Australia. The cities are ordered in ascending order in terms of their median wind gust speed.\n\n\n\nRemark: The four components within reorder() should be read as follows: (i) We want to reorder the values in Location, (ii) which should be based on the variable WindGustSpeed, (iii) the value to be used for the reordering is the median and (iv) ignore any missing values when calculating the median.\nBy ordering the violin plots, we can directly draw the conclusion that Adelaide has the lowest median wind gust speed, while Sydney has the highest. There are also other conclusions that are worth pointing out, such as the differences in terms of highest observed wind gust speeds.\n\nIn the previous section we generated plots using the structure [ + _. ] and this allowed us to create several type of plots and to use multiple visual cues. The following table lists the types of plots we explored so far (plus the functions for generating bar plots):\n\n\n\n\n\n\n\nType of plot\n\\(\\mathrm{\\texttt{&lt;GEOM}}\\_\\mathrm{\\texttt{FUNCTION&gt;}}\\)\nVisual cues we may use\n\n\n\nScatter plot\ngeom_point\nshape, shade, colour, size\n\n\nLine plot\ngeom_line\nshade, colour, linetype, size\n\n\n\ngeom_step\nshade, colour, linetype, size\n\n\nBar plot\ngeom_bar\nshade, colour, size\n\n\n\ngeom_col\nshade, colour, size\n\n\nHistogram\ngeom_histogram\nshade, colour, linetype\n\n\nBox plot\ngeom_boxplot\nshade, colour\n\n\nDensity plot\ngeom_density\nshade, colour, linetype\n\n\nViolin plot\ngeom_violin\nshade, colour, linetype\n\n\n\n\nWe also covered a few additional aspects, such as using facet_wrap() to create facets and labs() to specify the axes labels. In this section we consider the remaining plot elements described in Section 2.1:\n\nChanging the coordinate system to polar coordinates\nChanging the scale of the x-axis (y-axis)\n\nWe will also explore how to change the font size of the labels and the colour scheme in our plot. This will give us a lot of flexibility to visualize data.\n\nWe saw in Section 2.2 that ggplot() uses the Cartesian coordinate system by default. In Section 2.1.3 we highlighted that we sometimes want to use polar coordinates, for instance, when displaying wind direction. The coord_polar() function in ggplot2 allows us to switch from Cartesian to polar coordinates. Let’s consider two cases where such a transformation may be useful.\n\nIn Figures @ref(fig:BVWind1) and @ref(fig:BVWind2) we used plots with polar coordinates to explore wind direction and speed for Bela Vista, Brazil. We can reproduce these plots in ggplot2:\n\nlibrary(patchwork) # required to place plots next to each other\nwind_BV &lt;- read.csv(\"data/wind_bela_vista.csv\" )\n\ng1 &lt;- ggplot( wind_BV, aes( x=Wind.Direction ) ) + \n  geom_histogram( bins = 120 ) + coord_polar() + \n  labs( x=\"Wind Direction\" )\ng2 &lt;- ggplot( wind_BV, aes( x=Wind.Direction, y=Gust.Speed ) ) +\n  geom_point() + geom_smooth() + coord_polar( theta=\"x\" )  + \n  labs( x=\"Wind Direction\", y=\"Wind gust in m/s\" )\ng1 + g2\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\nHistogram illustrating the frequency of wind direction (left) and scatter plot of wind direction vs wind speed (right) for Bela Vista, Brazil. Both plots use polar coordinates. The solid line in the right plot shows the average wind speed for each wind direction.\n\n\n\nThe option \\(\\mathrm{\\texttt{theta=\"x\"}}\\) in coord_polar() specifies that the angle should be defined by the x-axis. We do not have to do anything else - ggplot2 is doing all the calculations for us.\nRemark 1: The R package patchwork makes it easy to place two graphics created by ggplot2 next to each other by using the + sign. There are more options available - have a look at the documentation for the package.\nRemark 2: The example also shows that we can use multiple geom_..() functions in the same plot. Here, we used geom_smooth() to add a line representing the average wind speed in each direction to the plot. However, we note that the line does not match up at \\(0^{\\circ}\\). This is not particularly elegant, but there is not a very easy fix to this.\nAre there any other plots we should create to explore the distribution of wind direction and speed of wind gusts at Bela Vista, Brazil?\n\nIn a pie chart we use the size of the angle as a visual cue and such a plot may be useful to visualize proportions. The following R code illustrates how to create a pie chart using ggplot2:\n\ndf &lt;- data.frame( \"prob\" = c(0.3,0.4,0.3), \"group\" = c(\"A\",\"B\",\"C\") )\nggplot( df, aes( x=\"\", y=prob, fill=group ) ) + \n  geom_col() + coord_polar( theta=\"y\" ) + labs( x=\"\", y=\"\" )\n\n\n\nExample of a pie chart with three slices.\n\n\n\nThe code first creates a plot on Cartesian coordinates - a stacked bar plot in this case - which is then converted to polar coordinates. To see this, you may want to have a look at the plot you obtain when removing coord_polar() from the code above.\n\nWe saw in Section 2.1.5 that changing the scale of one (or more) variables in a plot can help with the data analysis. In applications, transformations are often used to reduce the influence of extreme outliers in the plot. For instance, by considering logarithmic scales in Section 2.1.5, the three mammals with very high brain weight in the data appeared less extreme, and we were instead able to see the possible linear relationship on logarithmic scale between brain and body weight.\nWhen using ggplot(), a linear scale is used by default. The function coord_trans() enables us to change the scale of the x-axis or y-axis. The most common transformations are logarithmic (\\(\\mathrm{\\texttt{x=\"log\"}}\\) or \\(\\mathrm{\\texttt{x=\"log10\"}}\\)) and square root (\\(\\mathrm{\\texttt{x=\"sqrt\"}}\\)).\n\nThe data in “Facebook.csv” contains data related to messages posted by a few Olympic athletes. We want to explore the relation between number of likes (received for individual posts) and the number of followers of the athlete. Let’s produce two plots, one with linear scales and one with logarithmic scales:\n\nFacebook &lt;- read.csv(\"data/facebook.csv\", header=TRUE )\n\ng  &lt;- ggplot( Facebook, aes( x=follow, y=postlikes ) ) + \n  labs( x=\"Number of Followers\", y=\"Number of likes\" )\ng1 &lt;- g + geom_point() \ng2 &lt;- g + geom_point() + coord_trans( x=\"log\", y=\"log\" )\ng1 + g2\n\n\n\nNumber of followers vs number of likes on linear scale (left) and logarithmic scale (right) for Facebook posts by a group of Olympic athletes.\n\n\n\nWe see that the two plots provide quite different information: The graphic with log-transformed scales shows a possible linear relationship between log(number of followers) and log(number of likes), which is not visible when considering the plot with linear scales.\nRemark: If you want to use another transformation than logarithmic or square root, you can specify it within ggplot. For instance, we could use\n\nggplot( Facebook, aes( x=log(follow), y=log(postlikes) ) ) + geom_point() +\n  labs( x=\"log(Number of Followers)\", y=\"log(Number of likes)\" )\n\nYou have to be aware that the numbers along the axes differ in this case, and you have to change the axis labels to highlight that the values are on logarithmic scale.\n\nWhen we produce plots, we may find that, for instance, the axis labels are too small. Further, we may want to change the margins around our graphics. The theme() function allows us to do all this (and much more).\nIn Figure @ref(fig:Facebook) the axis labels are quite small and it may be nice to have a little bit of a gap between the plots. Let’s use the theme() function to achieve this. To visualize the difference, we only alter the setup of the second plot.\n\ng2 &lt;- g2 +\n  theme( plot.margin=margin( t=0, l=100, b=0, r=0 ),\n         axis.title=element_text(size=16),\n         axis.text=element_text(size=14) )\ng1 + g2\n\n\n\nNumber of followers vs number of likes on linear scale (left) and logarithmic scale (right) for Facebook posts by a group of Olympic athletes.\n\n\n\nWe see that the gap between the plots has widened, and that the font size of the axis labels and numbers in the right plot have increased. Font size in ggplot2 is specified via element_text(size=..):\n\nFont size of the title is changed with theme( title=element_text(size=..) )\nFont size of the axis labels is changed with theme( axis.title=element_text(size=..) )\nFont size in the legend can be changed with theme( legend.title=element_text(size=..) ) and theme( legend.text=element_text(size=..) )\n\nRemark: Making sure that labels are provided in a suitable font size is important. The gap between the plots is more of a personal preference.\n\nSo far we used the default colour scheme provided by ggplot2. There are situations, however, where we may want to change the colour scheme. One easy way to achieve this is by using the functions scale_filler_brewer() and scale_colour_brewer() in ggplot2 - which of these to use depends on whether you specified fill=.. or colour=.. in aes().\nExample: Let’s reproduce the box plots in Section 2.2.6, but with an orange colour scheme\n\nAUS &lt;- read.csv(\"data/weatheraustralia.csv\" )\nggplot( AUS, aes( x=Location,y=WindGustSpeed ) ) +\n  geom_boxplot( aes(fill=Location) ) + \n  labs( y=\"Speed of wind gust in km/h\" ) + \n  scale_fill_brewer( palette=\"Oranges\" ) + theme_bw() + \n  theme( axis.title=element_text(size=14), axis.text=element_text(size=14) )\n\n\n\nBox plots of the speed of wind gust for 5 cities in Australia.\n\n\n\nRemark: We used theme_bw() to change the background colour from grey to white.\nThere are multiple colour blind friendly patterns available for scale_filler_brewer() and scale_colour_brewer(), which you can view using\n\nlibrary( RColorBrewer )\ndisplay.brewer.all( colorblindFriendly = TRUE )\n\n\n\nList of colour blind friendly palettes that can be used to visualize discrete variables in ggplot2.\n\n\n\nNote, the colour schemes above are useful when applied to visualize a discrete variable with a small number of different values, such as the five Australian cities. We will see in Chapter [4][Spatial Data Analysis] how to change the colour scheme when visualizing a continuous random variable.\n\nGenerally speaking, ggplot2 plots different columns in a data frame against each other, and each row is considered as a single observation. However, in practice the data structure may not be as required.\nThe functions pivot_wider() and pivot_longer() in the tidyr package may provide one way to address this. Before considering an example, let’s load the tidyr package:\n\nlibrary( tidyr )\n\n\nThe file “Manaus Temperature.csv” provides the average temperature for each month in the years 1910-2019 for the city of Manaus, Brazil. Let’s load and investigate the data:\n\nManaus_raw &lt;- read.csv(\"data/manaus_temperature.csv\" )\nslice_head( Manaus_raw, n=4 )\n\n  YEAR  JAN  FEB  MAR  APR  MAY  JUN  JUL  AUG  SEP  OCT  NOV  DEC\n1 1910 27.3 27.0 26.5 26.2 27.2 27.5 27.7 28.0 29.0 28.3 28.3 27.8\n2 1911 27.0 27.4 27.4 27.3 27.2 27.0 27.4 28.3 29.0 29.1 28.8 28.3\n3 1912 29.0 28.8 28.3 28.0 27.3 28.1 27.4 28.8 28.3 29.3 29.2 27.5\n4 1913 27.2 28.1 27.3 27.6 27.0 27.6 27.7 27.7 28.7 28.7 28.8 28.5\n\n\nWe see that each row corresponds to one year of data. If we wanted to compare two months with each other, the data structure would be ideal for us to create a scatter plot with ggplot2. Let’s compare the temperatures for January and February:\n\nggplot( Manaus_raw, aes( \"x\"=JAN, \"y\"=FEB ) ) + geom_point() + \n  labs( x=\"Average Temperature in January\", y=\"Average Temperature in February\")\n\n\n\nScatter plot of the reported average temperatures for January and February for Manaus, Brazil.\n\n\n\nThe plot looks very odd and some of the data points have a value of \\(999.9\\). Since such high temperatures are highly unlikely, we conclude that the value \\(999.9\\) is used to indicate missing data. Let’s replace these values for January and February by \\(\\mathrm{\\texttt{NA}}\\). We can do this using case_when() or by using the na_if() function in dplyr:\n\nManaus &lt;- Manaus_raw %&gt;% \n  mutate( JAN = na_if( JAN, 999.9 ), FEB = na_if( FEB, 999.9 ) )\n\nWe can now create the plot again\n\nggplot( Manaus, aes( \"x\"=JAN, \"y\"=FEB ) ) + geom_point() + \n  labs( x=\"Average Temperature in January\", y=\"Average Temperature in February\") +\n  theme( axis.title=element_text(size=16), axis.text=element_text(size=14) )\n\nWarning: Removed 16 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\nScatter plot of the monthly average temperature for January and February for Manaus, Brazil.\n\n\n\nWe see that there is a positive correlation between the average monthly temperatures for Sao Paulo and Rio de Janeiro.\n\nLet’s assume that we also wanted to explore average temperature over time. In this case, a line plot would be a good choice. However, the data frame provides no single column which contains the monthly average temperatures.\nThe function pivot_longer() allows us to change the structure of the data frame by combining the columns JAN to DEC into a single column\n\nManaus_long &lt;- Manaus_raw %&gt;%\n  pivot_longer( cols=JAN:DEC, names_to=\"Month\" ) %&gt;%\n  rename( Temperature = value )\nslice_head( Manaus_long, n=3 )\n\n# A tibble: 3 × 3\n   YEAR Month Temperature\n  &lt;int&gt; &lt;chr&gt;       &lt;dbl&gt;\n1  1910 JAN          27.3\n2  1910 FEB          27  \n3  1910 MAR          26.5\n\n\nSo we have converted the original table to a narrower but substantially longer table with 3 columns; the pivot_longer() function by default stores the observed monthly averages in a column named value, which we renamed to Temperature.\nIf we wanted to reverse back to the original format, we would use the function pivot_wider(),\n\nManaus_wide &lt;- Manaus_long %&gt;% \n  pivot_wider( names_from=Month, values_from=Temperature )\n\nEach row in Manaus_long now corresponds to one month instead of one year. The one challenge that remains is to convert the variables YEAR and MONTH into a single variable that represents the date. There is unfortunately no easy way, but the following code does the job\n\n## Convert abbreviation for month into number\nManaus_long &lt;- \n  Manaus_long %&gt;% \n  mutate( Month = case_when( \n    Month == \"JAN\" ~ \"01\", Month == \"FEB\" ~ \"02\", Month == \"MAR\" ~ \"03\", \n    Month == \"APR\" ~ \"04\", Month == \"MAY\" ~ \"05\", Month == \"JUN\" ~ \"06\",\n    Month == \"JUL\" ~ \"07\", Month == \"AUG\" ~ \"08\", Month == \"SEP\" ~ \"09\", \n    Month == \"OCT\" ~ \"10\", Month == \"NOV\" ~ \"11\", Month == \"DEC\" ~ \"12\"\n    ) \n  )\n\n## Combine year and month and convert to date\nManaus_long &lt;- Manaus_long %&gt;%\n  mutate( Date = paste( Manaus_long$YEAR, Manaus_long$Month, sep=\"-\" ) ) %&gt;%\n  mutate( Date = ym( Date ) )\n\nFinally, we can create our line plot. We have to keep in mind that we still have entries of value 999.9 which we do not want to plot. We again replace values of 999.9 with \\(\\mathrm{\\texttt{NA}}\\):\n\nManaus_long %&gt;%\n  mutate( Temperature = na_if( Temperature, 999.9 ) ) %&gt;%\n  ggplot( aes(\"x\"=Date, \"y\"=Temperature) ) + \n  geom_line() + geom_smooth() +\n  labs( y=\"Average Monthly Temperature\") + theme_bw() +\n  theme( axis.title=element_text(size=16), axis.text=element_text(size=14) )\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\nAverage monthly temperature for Manaus, Brazil, between 1910 and 2019.\n\n\n\nThe plot indicates an increase in the average monthly temperature from about 27.5 to 29 degree Celsius over the time period.\nRemark: The last piece of code shows that we can use the pipe together with the functions from ggplot2.\n\nWe covered some of the principles regarding data visualization:\n\nWhen designing your data graphic, ensure that the main message/aspect is clearly visible and provide an interpretation of your plot. Avoid presenting plots that are not focused towards answering the research question.\nThe important types of graphics we use for data visualization and exploration are line plot, scatter plot, bar plot, histogram, density plot, box plot and violin plot.\n\nGraphics can be discussed in terms of four elements:\n\nVisual cues\nCoordinate system\nScale\nContext\n\n\nThe ggplot2 R package provides a wide range of tools for creating data graphics from a given data frame. This includes changing the coordinate system, the scale and selecting a wide range of types of graphics.\nFor complex data sets it is often useful to use facets and a wide range of visual cues. This may improve accessibility for the reader.\nIn practice we often have to restructure the data using the dplyr and tidyr packages before creating the data graphic.",
    "crumbs": [
      "Lecture Notes",
      "Data Visualization"
    ]
  },
  {
    "objectID": "lecture_notes/02-DataVisualization.html#background-on-data-visualization",
    "href": "lecture_notes/02-DataVisualization.html#background-on-data-visualization",
    "title": "Data Visualization",
    "section": "",
    "text": "Before starting to create plots in R, we establish a framework to analyze plots in terms of four basic elements: visual cues, coordinate system, scale and context. Understanding these elements will help us with producing our own plots later.\n\nVisual cues are graphical elements that draw the audience to the aspects we want them to focus on. The book “Data points: Visualization that means something” by Nathan Yau (link provided on Moodle) lists nine distinct visual cues to encode a category or quantity:\n\nPosition (quantity) - relation to other things\nLength (quantity) - size in one dimension\nAngle (quantity) - width of angle may, for instance, represent proportions (pie chart)\nDirection (quantity) - slope of line\nShape (category) - which observations are in the same group\nArea (quantity) - size in two dimensions\nVolume (quantity) - size in three dimensions\nShade (quantity or category) - shade in comparison to others, or grouping\nColour (quantity or category) - colour in comparison to others, or grouping\n\nResearch has shown that our ability to perceive differences in magnitude descends in this order. One of many publications supporting this argument is “Graphical perception: Theory, experimentation, and application to the development of graphical methods.”, which you can find on Moodle.\nImportant: One crucial conclusion is that we should not rely too much on colour. Many people have colour deficiencies, which makes it very hard for them to distinguish certain colours. Consequently, before using colour, we should consider whether we could use shapes or shades instead.\nRemark: In this course we focus on creating 2D graphics. While 3D plots and animations allow us to visualize a larger number of variables (and you may think they look more impressive), I would avoid using such plots except for a very limited number of cases. That’s because it is often difficult to see the exact positions of the points.\n\nThe data set “Freediving Records.csv” provides information on the progression of the world record in multiple disciplines for men and women. We will focus on the discipline “dynamic apnea with fins (DYN)” and visualize how the world records for men and women have progressed over time:\n\n\n\n\nDevelopment of the world record in dynamic apnea with fins (DYN) for men and women between 1993 and 2020.\n\n\n\nWe can identify that the following visual cues have been used:\n\nShape and colour indicate whether the observations refer to the world record for men or women. Note, there is no issue with using multiple cues for the same information.\nLength of line is used to convey two pieces of information: (i) the length of the line in horizontal direction indicates the time it took until the world record was broken, and (ii) the length of the line in vertical direction represents the magnitude of improvement.\nPosition is used to compare the world records for men and women (both lines are provided in the plot).\nShape is used to highlight the times when a world record was broken - this makes it is easy to count the number of times the record was broken. Without this visual cue, such information would be much harder to extract from the plot.\n\nChoosing a suitable coordinate system is critical to present the data accurately and in a meaningful way. The three most common coordinate systems used in data science are\n\nCartesian:\n\nOur familiar (\\(x,y\\))-rectangular coordinate system with two perpendicular axes.\n\nPolar:\n\nPoints are identified by their radius \\(r\\) (distance from the origin) and angle \\(\\theta\\). A point (\\(x,y\\)) in Cartesian coordinates can be transformed to polar coordinates using the relationship [ (x,y) = (r, r), r=. ]\n\nGeographical:\n\nIn the chapter on spatial data analysis, we will work with points located across the earth, with their positions being defined by longitude and latitude.\n\n\nThere are two common cases when we may want to consider polar coordinates:\n\nPie charts\nVariables which naturally lie on a circle, such as wind direction.\n\nTip: Since Position and Length are better visual cues than Angle, we should prefer Cartesian coordinates to polar coordinates. For instance, before using pie charts, consider whether the same information can be displayed effectively in a bar plot. However, we will see some examples where polar coordinates may be considered the better choice.\n\nHourly weather data was collected for Bela Vista, Brazil, for 2017 and 2018. Suppose we were asked to explore the distribution of wind direction and the relation between wind direction and speed of wind gusts.\nTo analyse the distribution of wind direction, we may create a histogram of the collected data. Let’s compare the histograms obtained for the Cartesian and polar coordinate systems (both display frequency):\n\n\n\n\nFrequency of wind direction for Bela Vista, Brazil, in 2017 and 2018 displayed using Cartesian coordinates (left) and polar coordinates (right).\n\n\n\nBoth plots, Cartesian (left) and polar (right), show that the wind predominately comes from a north-easterly direction. The right plot is a tick nicer, because it better handles that \\(0^{\\circ}=360^{\\circ}\\) in terms of wind direction, which is recorded as an angle.\nLet’s turn to analyzing the relation between wind direction and speed of wind gusts. For this we create plots which map wind direction against the speed of the wind gusts, again using different coordinate systems:\n\n\n\n\nWind direction versus speed of wind gust for Bela Vista in 2017 and 2018 displayed using Cartesian coordinates (left) and polar coordinates (right).\n\n\n\nWhat can we conclude about the relation between wind direction and speed of wind gusts?\nI personally prefer the left plot because it indicates the difference in frequency of wind directions. The right plot (using polar coordinates) does not provide this information and it seems almost as if wind direction is uniformly distributed - so we would need the histogram in Figure @ref(fig:BVWind1) to correctly interpret the plot.\n\nThe concepts of scale and context refer to the choice of axes and the labeling of the data graphic respectively.\n\nScales allow us to translate values into visual cues by influencing, for instance, the distance (length) between points in a scatter plot. When choosing scales, we have to consider how the displayed distances translate into meaningful differences. Each coordinate axis can have its own scale, and we have three different choices:\nNumerical: Numeric quantities, such as speed, age, etc., are commonly set on a linear, logarithmic or percentage scale.\nCategorical: Categorical variables may have no ordering (political parties), or be ordinal (restaurant ratings). Ordinal variables differ from numeric quantities in that distances are unknown (or not meaningful). For instance, a first class degree is better than a 2.1, but what does this mean in terms of distance?\nTime: While being a numeric quantity, time has some special properties: 1) it can be demarcated by year, month,.. and 2) it can be considered periodical. This second aspect can be highlighted using polar coordinates as seen in Section 2.1.4.\n\nData graphics are provided to aid the reader/viewer with making meaningful comparisons. Context can be added in the form of titles, subtitles and axis labels that explain what is being shown, including the scales and units. It sometimes also helps to include reference points or lines. While we should avoid cluttering or providing excessive annotations, it is necessary to provide proper context.\n\nThe following two plots both illustrate the relation between body weight and brain weight for several mammals, but they use different scales:\n\n\n\n\nBody weight vs brain weight for 62 mammals on linear scale (left) and logarithmic scale (right).\n\n\n\nWe make two observations:\n\nLinear scales were used in the left plot, while logarithmic scales were used in the right plot - this context was provided via the title.\nThe right plot is more informative as it shows a linear relationship between body and brain weight on logarithmic scale. This aspect is not clear in the left plot, and a viewer may focus on the three mammals with the highest brain weight as they appear to be quite different from the rest.",
    "crumbs": [
      "Lecture Notes",
      "Data Visualization"
    ]
  },
  {
    "objectID": "lecture_notes/02-DataVisualization.html#analysis-of-australian-weather-data-using-ggplot2",
    "href": "lecture_notes/02-DataVisualization.html#analysis-of-australian-weather-data-using-ggplot2",
    "title": "Data Visualization",
    "section": "",
    "text": "After outlining the different elements of a plot in the previous section, we now explore how we can create informative plots using the ggplot2 R package\n\nlibrary( ggplot2 )\n\nWe will introduce and utilize a wide range of plots to analyze historical weather data for five Australian cities. The data is provided on Moodle as “WeatherAustralia.csv” and we start by loading the data and looking at the first few entries:\n\nAUS &lt;- read.csv(\"data/weatheraustralia.csv\" )\nslice_head( AUS, n=5 )\n\n        Date Location MinTemp MaxTemp Rainfall WindGustSpeed\n1 01/01/2009   Sydney    17.7    35.1        0            72\n2 02/01/2009   Sydney    18.5    23.0        0            63\n3 03/01/2009   Sydney    16.9    23.2        0            NA\n4 04/01/2009   Sydney    18.7    27.1        0            65\n5 05/01/2009   Sydney    20.2    31.6        0            63\n\n\nWe see that the data provide daily information on minimum and maximum temperature, amount of rainfall and wind speed. Further, the data also include some missing values, as highlighted by the \\(\\mathrm{\\texttt{NA}}\\) entries.\nIn the following, we perform a data exploration which includes the creation and interpretation of multiple plots. At the end of the analysis, you will be familiar with the general functionality of the ggplot2 package. Further types of plots are listed on the ggplot2 cheat sheet (provided on Moodle). I would advise you to try creating some of them for practice, as they may be useful.\nImportant: In this section we focus on the different types of plots and visual cues. The other elements described in Section 2.1, coordinate system, scale and context, will be considered in Section 2.3.\n\nThe first step is to call the function ggplot() and we usually specify the following inputs:\n\nThe name of the data frame that contains the data we want to plot\nThe names of the variables which specify the axes. This is done using the function aes(), which refers to aesthetics (we will see this very often).\n\nSuppose we want to create a scatter plot of minimum against maximum temperature for the five Australian cities. To initialize the plot, we specify\n\nPlotAUS &lt;- ggplot( AUS, aes( x=MinTemp, y=MaxTemp ) )\n\nHowever, if we call PlotAUS in R, we will see a Cartesian coordinate system, but no points. This is because the coordinate system and visual cues are specified using separate functions in ggplot2. We will consider in the next subsection how to add points as an additional layer.\nRemark: While it is important to use meaningful variable names when programming, I usually make an exception when using ggplot2. For instance, instead of PlotAUS, we could also call it g (for graphic) - I will later use this for brevity.\n\nThe function geom_point() adds the points to the coordinate system created by ggplot(). Returning to the Australian weather data, we generate the scatter plot of daily minimum and maximum temperature using\n\nPlotAUS + geom_point()\n\n\n\nMinimum versus maximum observed daily temperature for five Australian cities between 2008 and 2017.\n\n\n\nWe observe a positive correlation between minimum and maximum daily temperature. However, this plot does not highlight that the data are coming from five different cities. In other words, the plot does not allow us to explore differences between the cities.\nOne possible solution is to use the visual cues shape and colour to indicate to which city a data point belongs. Specifically, we specify via aes() that the variable Location should be used to determine the shape and colour of the points created by the geom_point() function:\n\nPlotAUS + geom_point( aes( shape=Location, color=Location ) )\n\n\n\nMinimum versus maximum observed daily temperature for five Australian cities between 2008 and 2017, with the city being highlighted using the visual cues of shape and colour.\n\n\n\nRemark: If we wanted to use shade, we would have specified \\(\\mathrm{\\texttt{aes( alpha=Location )}}\\).\nWhile our plot now makes clear that the data come from different cities, it is still very cluttered. This makes it hard to draw conclusions on differences between the five Australian cities. Luckily, there is a better option available, which we consider next.\n\nInstead of creating a single plot which contains all points, it seems a nice idea to have a separate plot for each city. In other words, we want to split the data using the variable Location and create one plot per subset.\nThis type of plot is called a facet plot and it provides a simple and effective way to display the data for the separate levels of a categorical variable.\nTo create the facet plot, we use the function facet_wrap() and change the axes labels using the labs() function:\n\nPlotAUS + geom_point() +\n  facet_wrap( ~Location ) +\n  labs( x=\"Minimum daily temperature\", y=\"Maximum daily temperature\" )\n\n\n\nPlots of minimum versus maximum daily temperature between 2008 and 2017 for five Australian cities.\n\n\n\nOur plot now reveals that Darwin is quite different from the other four cities in terms of the distribution of minimum and maximum daily temperature, in particular, in terms of the range of values.\nWhat may be the reason for this difference? What else can we conclude?\n\nAs for the river flow data in Section [1.1.4][Example: Loading and cleaning NRFA river flow data], we may want to explore how a variable changes over time for one of the five cities.\nScatter plots are often not the right choice for such a task, because it’s hard to see patterns in the data. Instead we create a line plot, where the length of the line connecting consecutive dates illustrates the magnitude of change in the values of the variable.\nLet’s see how we can create a line plot for daily maximum temperature over time for Darwin. We start by converting the variable Date in the data frame to the correct type,\n\nAUS &lt;- AUS %&gt;% mutate( Date = as_date( Date, format=\"%d/%m/%Y\" ) )\n\nThe next step is to extract the subset of observations for Darwin, which we store in a separate data frame called Darwin:\n\nDarwin &lt;- filter( AUS, Location == \"Darwin\" )\n\nA line plot is then created by using the geom_line() function, again by first defining the axes in the ggplot() function:\n\nggplot( Darwin, aes( x=Date, y=MaxTemp ) ) + geom_line() + \n  labs( x=\"Date\", y=\"Maximum daily temperature\" )\n\n\n\nTime series plot of daily maximum temperature for Darwin between 2008 and 2017.\n\n\n\nTo create such a (time series) plot for all five cities, we again use facet_wrap(), and we use colour and shape (line type) to highlight the different cities:\n\nggplot( AUS, aes( x=Date, y=MaxTemp ) ) + facet_wrap( ~Location ) + \n  geom_line( aes( color=Location, linetype=Location ) ) + \n  labs( x=\"Date\", y=\"Maximum daily temperature\" )\n\n\n\nTime series plot of daily maximum temperature for five Australian cities between 2008 and 2017.\n\n\n\nThe gap in the plot for Melbourne is due to the data being missing for this time period. One conclusion we draw from the plot is that the maximum daily temperature is less varied for Darwin than the other cities, which exhibit a clear seasonal pattern.\nRemark 1: To draw steps as in Section 2.1.2, we would use geom_step() instead of geom_line().\nRemark 2: The use of colour and shape in Figure @ref(fig:DateTempFacet) is not really necessary. We just did it do illustrate that visual cues can be used together with facet_wrap().\n\nWe now want to investigate the distribution of a single variable, such as the speed of the wind gusts in one (or more) of the cities. Histograms and density plots are useful in such cases. You already created histograms in Year 1 Probability & Statistics and we analyzed such a plot in Section 2.1.4. We start by producing a histogram using ggplot2 and then introduce the density plot in more detail.\n\nThe ggplot2 package provides the function geom_histogram() to create a histogram. As for the hist() function you used before, we have to set a suitable number of bins, and this is done using the bins option inside the geom_histogram() function.\nLet’s return to the data for Darwin. To create a histogram for wind speed gusts, we have to call ggplot() and geom_histogram(), but we now only specify the x-axis:\n\nggplot( Darwin, aes( x=WindGustSpeed ) ) + geom_histogram( bins=20 ) + \n  labs( x=\"Speed of wind gust in km/h\", y=\"Count\" )\n\n\n\nHistogram of the speed of wind gusts for Darwin between 2008 and 2017.\n\n\n\nWhat could be a sensible distribution for the speed of wind gusts, based on the histogram?\n\nA density plot is pretty much a smoothed version of the histogram. Given data \\(x_1,\\ldots,x_n\\), we define the estimate \\(\\hat{f}_X(\\cdot)\\) for the probability density function \\(f_X(\\cdot)\\) of the random variable \\(X\\) as \\[\\begin{equation}\n\\hat{f}_X(x) = \\frac{1}{nh}\\sum_{i=1}^{n} K\\left(\\frac{x-x_i}{h}\\right), \\qquad x\\in\\mathbb{R},\n(\\#eq:KDE)\n\\end{equation}\\] where \\(K(\\cdot)\\) is termed the kernel and \\(h\\) is called the bandwidth. The kernel is a non-negative probability density function. One common choice is to set \\(K(\\cdot)\\) as the density of the standard normal distribution, with [ X(x) = {i=1}^{n}{-}. ]\nIn principle, the bandwidth \\(h\\) has to be set by us. If \\(h\\) is too small, the density plot will look very jittered, while a too large \\(h\\) will obscure the underlying data structure. Consequently, care should be taken when setting the bandwidth.\nRemark 1: When generating density plots in R, a suitable value for \\(h\\) is often provided automatically. However, we sometimes have to set the bandwidth manually.\nRemark 2: It is usually sufficient to provide either the histogram or the density plot, because they visualize similar aspects of the data. Note, the histogram should be used for discrete data.\nIn ggplot2, geom_density() is used to create density plots and, as for geom_histogram(), we only specify the x-axis. Let’s use this type of plot to compare the distributions of the speed of wind gusts for Darwin and Adelaide. To aid the comparison, we place the estimates for the two cities in the same plot:\n\nWeatherAD &lt;- filter( AUS, Location %in% c(\"Adelaide\",\"Darwin\") )\nggplot( WeatherAD, aes( x=WindGustSpeed ) ) +\n  geom_density( aes( linetype=Location, color=Location ), size=1.2 ) +\n  labs( x=\"Speed of wind gust in km/h\", y=\"Density\" )\n\n\n\nDensity plots of the speed of wind gusts for Adelaide (solid) and Darwin (dashed) for 2008–2017.\n\n\n\nThe two estimated curves indicate that Adelaide and Darwin differ in the distribution of wind gust speeds. For instance, Adelaide observes wind gust speeds below 30 km/h more often than Darwin.\nRemark 1: The option \\(\\mathrm{\\texttt{size=1.2}}\\) in geom_density() increases the thickness of the line in the plot - you can set size to any positive value, and higher values will give thicker lines. If you wanted to specify the bandwidth \\(h\\) in @ref(eq:KDE), you have the option \\(\\mathrm{\\texttt{bw=..}}\\).\nRemark 2: Density plots can sometimes be misleading because they are a smoothed version of the histogram. Although Adelaide and Darwin appear to have a similar density in Figure @ref(fig:DAWind) when it comes to high wind speeds, the highest value for Adelaide is 86 km/h, while it is 126 km/h for Darwin. Consequently, we should be cautious when drawing conclusions about the distribution tails based on density plots.\n\nBox plots and violin plots are useful for comparing a number of distributions. For instance, we may want to compare the distributions of wind gust speed for the five Australian cities. While we could produce a separate density plot for each city, box and violin plots tend to be a better choice.\nThe two types of plot differ in terms of the information they provide:\n\nBox plots visualize the median, interquartile range (25% and 75% quantile) and outliers.\nViolin plots visualize the density estimate \\(\\hat{f}_X(\\cdot)\\) as defined in Equation @ref(eq:KDE).\n\n\nIn ggplot2, box plots are created using the geom_boxplot() function. Let’s use this type of plot to compare the wind gust speeds across the five cities. We set the x-axis to the categorical variable Location, and the y-axis as speed of wind gust:\n\nggplot( AUS, aes( x=Location, y=WindGustSpeed ) ) + \n  geom_boxplot( aes( fill=Location ) ) + \n  labs( y=\"Speed of wind gust in km/h\" )\n\n\n\nBox plots of the speed of wind gusts for five Australian cities between 2008 and 2017.\n\n\n\nWe can extract a few details about the distributions of the speed of wind gusts for the five cities. For instance, when considering the median, Melbourne and Sydney record the strongest wind gusts, while Adelaide and Perth record the lowest wind gust speeds.\nRemark 1: The option \\(\\mathrm{\\texttt{fill=Location}}\\) gives each box plot a different colour.\nRemark 2: If we wanted a single box plot for a variable, we would only specify one of the axes.\n\nTo conclude our analysis, we compare the distribution of daily wind gust speeds across the five Australian cities using violin plots. This type of plot is generated using the geom_violin() function, and the syntax is the same as for geom_boxplot(). We make two additions compared to Figure @ref(fig:Box) though:\n\nA plot title is set using the labs() function.\nIt’s good practice to order box and violin plots, for instance, based on the median of the different subgroups. This is achieved using the reorder() function.\n\nPutting everything together, the five violin plots are generated using\n\nggplot( AUS, aes( x=reorder(Location, WindGustSpeed, median, na.rm=TRUE), \n                  y=WindGustSpeed ) ) + geom_violin() + \n  labs( x=\"Location\", y=\"Wind gust speed in mph\", \n        title=\"Wind gust speed across five Australian cities\" )\n\n\n\nViolin plots of wind speed across five cities in Australia. The cities are ordered in ascending order in terms of their median wind gust speed.\n\n\n\nRemark: The four components within reorder() should be read as follows: (i) We want to reorder the values in Location, (ii) which should be based on the variable WindGustSpeed, (iii) the value to be used for the reordering is the median and (iv) ignore any missing values when calculating the median.\nBy ordering the violin plots, we can directly draw the conclusion that Adelaide has the lowest median wind gust speed, while Sydney has the highest. There are also other conclusions that are worth pointing out, such as the differences in terms of highest observed wind gust speeds.",
    "crumbs": [
      "Lecture Notes",
      "Data Visualization"
    ]
  },
  {
    "objectID": "lecture_notes/02-DataVisualization.html#creating-advanced-plots-with-ggplot2",
    "href": "lecture_notes/02-DataVisualization.html#creating-advanced-plots-with-ggplot2",
    "title": "Data Visualization",
    "section": "",
    "text": "In the previous section we generated plots using the structure [ + _. ] and this allowed us to create several type of plots and to use multiple visual cues. The following table lists the types of plots we explored so far (plus the functions for generating bar plots):\n\n\n\n\n\n\n\nType of plot\n\\(\\mathrm{\\texttt{&lt;GEOM}}\\_\\mathrm{\\texttt{FUNCTION&gt;}}\\)\nVisual cues we may use\n\n\n\nScatter plot\ngeom_point\nshape, shade, colour, size\n\n\nLine plot\ngeom_line\nshade, colour, linetype, size\n\n\n\ngeom_step\nshade, colour, linetype, size\n\n\nBar plot\ngeom_bar\nshade, colour, size\n\n\n\ngeom_col\nshade, colour, size\n\n\nHistogram\ngeom_histogram\nshade, colour, linetype\n\n\nBox plot\ngeom_boxplot\nshade, colour\n\n\nDensity plot\ngeom_density\nshade, colour, linetype\n\n\nViolin plot\ngeom_violin\nshade, colour, linetype\n\n\n\n\nWe also covered a few additional aspects, such as using facet_wrap() to create facets and labs() to specify the axes labels. In this section we consider the remaining plot elements described in Section 2.1:\n\nChanging the coordinate system to polar coordinates\nChanging the scale of the x-axis (y-axis)\n\nWe will also explore how to change the font size of the labels and the colour scheme in our plot. This will give us a lot of flexibility to visualize data.\n\nWe saw in Section 2.2 that ggplot() uses the Cartesian coordinate system by default. In Section 2.1.3 we highlighted that we sometimes want to use polar coordinates, for instance, when displaying wind direction. The coord_polar() function in ggplot2 allows us to switch from Cartesian to polar coordinates. Let’s consider two cases where such a transformation may be useful.\n\nIn Figures @ref(fig:BVWind1) and @ref(fig:BVWind2) we used plots with polar coordinates to explore wind direction and speed for Bela Vista, Brazil. We can reproduce these plots in ggplot2:\n\nlibrary(patchwork) # required to place plots next to each other\nwind_BV &lt;- read.csv(\"data/wind_bela_vista.csv\" )\n\ng1 &lt;- ggplot( wind_BV, aes( x=Wind.Direction ) ) + \n  geom_histogram( bins = 120 ) + coord_polar() + \n  labs( x=\"Wind Direction\" )\ng2 &lt;- ggplot( wind_BV, aes( x=Wind.Direction, y=Gust.Speed ) ) +\n  geom_point() + geom_smooth() + coord_polar( theta=\"x\" )  + \n  labs( x=\"Wind Direction\", y=\"Wind gust in m/s\" )\ng1 + g2\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\nHistogram illustrating the frequency of wind direction (left) and scatter plot of wind direction vs wind speed (right) for Bela Vista, Brazil. Both plots use polar coordinates. The solid line in the right plot shows the average wind speed for each wind direction.\n\n\n\nThe option \\(\\mathrm{\\texttt{theta=\"x\"}}\\) in coord_polar() specifies that the angle should be defined by the x-axis. We do not have to do anything else - ggplot2 is doing all the calculations for us.\nRemark 1: The R package patchwork makes it easy to place two graphics created by ggplot2 next to each other by using the + sign. There are more options available - have a look at the documentation for the package.\nRemark 2: The example also shows that we can use multiple geom_..() functions in the same plot. Here, we used geom_smooth() to add a line representing the average wind speed in each direction to the plot. However, we note that the line does not match up at \\(0^{\\circ}\\). This is not particularly elegant, but there is not a very easy fix to this.\nAre there any other plots we should create to explore the distribution of wind direction and speed of wind gusts at Bela Vista, Brazil?\n\nIn a pie chart we use the size of the angle as a visual cue and such a plot may be useful to visualize proportions. The following R code illustrates how to create a pie chart using ggplot2:\n\ndf &lt;- data.frame( \"prob\" = c(0.3,0.4,0.3), \"group\" = c(\"A\",\"B\",\"C\") )\nggplot( df, aes( x=\"\", y=prob, fill=group ) ) + \n  geom_col() + coord_polar( theta=\"y\" ) + labs( x=\"\", y=\"\" )\n\n\n\nExample of a pie chart with three slices.\n\n\n\nThe code first creates a plot on Cartesian coordinates - a stacked bar plot in this case - which is then converted to polar coordinates. To see this, you may want to have a look at the plot you obtain when removing coord_polar() from the code above.\n\nWe saw in Section 2.1.5 that changing the scale of one (or more) variables in a plot can help with the data analysis. In applications, transformations are often used to reduce the influence of extreme outliers in the plot. For instance, by considering logarithmic scales in Section 2.1.5, the three mammals with very high brain weight in the data appeared less extreme, and we were instead able to see the possible linear relationship on logarithmic scale between brain and body weight.\nWhen using ggplot(), a linear scale is used by default. The function coord_trans() enables us to change the scale of the x-axis or y-axis. The most common transformations are logarithmic (\\(\\mathrm{\\texttt{x=\"log\"}}\\) or \\(\\mathrm{\\texttt{x=\"log10\"}}\\)) and square root (\\(\\mathrm{\\texttt{x=\"sqrt\"}}\\)).\n\nThe data in “Facebook.csv” contains data related to messages posted by a few Olympic athletes. We want to explore the relation between number of likes (received for individual posts) and the number of followers of the athlete. Let’s produce two plots, one with linear scales and one with logarithmic scales:\n\nFacebook &lt;- read.csv(\"data/facebook.csv\", header=TRUE )\n\ng  &lt;- ggplot( Facebook, aes( x=follow, y=postlikes ) ) + \n  labs( x=\"Number of Followers\", y=\"Number of likes\" )\ng1 &lt;- g + geom_point() \ng2 &lt;- g + geom_point() + coord_trans( x=\"log\", y=\"log\" )\ng1 + g2\n\n\n\nNumber of followers vs number of likes on linear scale (left) and logarithmic scale (right) for Facebook posts by a group of Olympic athletes.\n\n\n\nWe see that the two plots provide quite different information: The graphic with log-transformed scales shows a possible linear relationship between log(number of followers) and log(number of likes), which is not visible when considering the plot with linear scales.\nRemark: If you want to use another transformation than logarithmic or square root, you can specify it within ggplot. For instance, we could use\n\nggplot( Facebook, aes( x=log(follow), y=log(postlikes) ) ) + geom_point() +\n  labs( x=\"log(Number of Followers)\", y=\"log(Number of likes)\" )\n\nYou have to be aware that the numbers along the axes differ in this case, and you have to change the axis labels to highlight that the values are on logarithmic scale.\n\nWhen we produce plots, we may find that, for instance, the axis labels are too small. Further, we may want to change the margins around our graphics. The theme() function allows us to do all this (and much more).\nIn Figure @ref(fig:Facebook) the axis labels are quite small and it may be nice to have a little bit of a gap between the plots. Let’s use the theme() function to achieve this. To visualize the difference, we only alter the setup of the second plot.\n\ng2 &lt;- g2 +\n  theme( plot.margin=margin( t=0, l=100, b=0, r=0 ),\n         axis.title=element_text(size=16),\n         axis.text=element_text(size=14) )\ng1 + g2\n\n\n\nNumber of followers vs number of likes on linear scale (left) and logarithmic scale (right) for Facebook posts by a group of Olympic athletes.\n\n\n\nWe see that the gap between the plots has widened, and that the font size of the axis labels and numbers in the right plot have increased. Font size in ggplot2 is specified via element_text(size=..):\n\nFont size of the title is changed with theme( title=element_text(size=..) )\nFont size of the axis labels is changed with theme( axis.title=element_text(size=..) )\nFont size in the legend can be changed with theme( legend.title=element_text(size=..) ) and theme( legend.text=element_text(size=..) )\n\nRemark: Making sure that labels are provided in a suitable font size is important. The gap between the plots is more of a personal preference.\n\nSo far we used the default colour scheme provided by ggplot2. There are situations, however, where we may want to change the colour scheme. One easy way to achieve this is by using the functions scale_filler_brewer() and scale_colour_brewer() in ggplot2 - which of these to use depends on whether you specified fill=.. or colour=.. in aes().\nExample: Let’s reproduce the box plots in Section 2.2.6, but with an orange colour scheme\n\nAUS &lt;- read.csv(\"data/weatheraustralia.csv\" )\nggplot( AUS, aes( x=Location,y=WindGustSpeed ) ) +\n  geom_boxplot( aes(fill=Location) ) + \n  labs( y=\"Speed of wind gust in km/h\" ) + \n  scale_fill_brewer( palette=\"Oranges\" ) + theme_bw() + \n  theme( axis.title=element_text(size=14), axis.text=element_text(size=14) )\n\n\n\nBox plots of the speed of wind gust for 5 cities in Australia.\n\n\n\nRemark: We used theme_bw() to change the background colour from grey to white.\nThere are multiple colour blind friendly patterns available for scale_filler_brewer() and scale_colour_brewer(), which you can view using\n\nlibrary( RColorBrewer )\ndisplay.brewer.all( colorblindFriendly = TRUE )\n\n\n\nList of colour blind friendly palettes that can be used to visualize discrete variables in ggplot2.\n\n\n\nNote, the colour schemes above are useful when applied to visualize a discrete variable with a small number of different values, such as the five Australian cities. We will see in Chapter [4][Spatial Data Analysis] how to change the colour scheme when visualizing a continuous random variable.",
    "crumbs": [
      "Lecture Notes",
      "Data Visualization"
    ]
  },
  {
    "objectID": "lecture_notes/02-DataVisualization.html#changing-the-data-structure",
    "href": "lecture_notes/02-DataVisualization.html#changing-the-data-structure",
    "title": "Data Visualization",
    "section": "",
    "text": "Generally speaking, ggplot2 plots different columns in a data frame against each other, and each row is considered as a single observation. However, in practice the data structure may not be as required.\nThe functions pivot_wider() and pivot_longer() in the tidyr package may provide one way to address this. Before considering an example, let’s load the tidyr package:\n\nlibrary( tidyr )\n\n\nThe file “Manaus Temperature.csv” provides the average temperature for each month in the years 1910-2019 for the city of Manaus, Brazil. Let’s load and investigate the data:\n\nManaus_raw &lt;- read.csv(\"data/manaus_temperature.csv\" )\nslice_head( Manaus_raw, n=4 )\n\n  YEAR  JAN  FEB  MAR  APR  MAY  JUN  JUL  AUG  SEP  OCT  NOV  DEC\n1 1910 27.3 27.0 26.5 26.2 27.2 27.5 27.7 28.0 29.0 28.3 28.3 27.8\n2 1911 27.0 27.4 27.4 27.3 27.2 27.0 27.4 28.3 29.0 29.1 28.8 28.3\n3 1912 29.0 28.8 28.3 28.0 27.3 28.1 27.4 28.8 28.3 29.3 29.2 27.5\n4 1913 27.2 28.1 27.3 27.6 27.0 27.6 27.7 27.7 28.7 28.7 28.8 28.5\n\n\nWe see that each row corresponds to one year of data. If we wanted to compare two months with each other, the data structure would be ideal for us to create a scatter plot with ggplot2. Let’s compare the temperatures for January and February:\n\nggplot( Manaus_raw, aes( \"x\"=JAN, \"y\"=FEB ) ) + geom_point() + \n  labs( x=\"Average Temperature in January\", y=\"Average Temperature in February\")\n\n\n\nScatter plot of the reported average temperatures for January and February for Manaus, Brazil.\n\n\n\nThe plot looks very odd and some of the data points have a value of \\(999.9\\). Since such high temperatures are highly unlikely, we conclude that the value \\(999.9\\) is used to indicate missing data. Let’s replace these values for January and February by \\(\\mathrm{\\texttt{NA}}\\). We can do this using case_when() or by using the na_if() function in dplyr:\n\nManaus &lt;- Manaus_raw %&gt;% \n  mutate( JAN = na_if( JAN, 999.9 ), FEB = na_if( FEB, 999.9 ) )\n\nWe can now create the plot again\n\nggplot( Manaus, aes( \"x\"=JAN, \"y\"=FEB ) ) + geom_point() + \n  labs( x=\"Average Temperature in January\", y=\"Average Temperature in February\") +\n  theme( axis.title=element_text(size=16), axis.text=element_text(size=14) )\n\nWarning: Removed 16 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\nScatter plot of the monthly average temperature for January and February for Manaus, Brazil.\n\n\n\nWe see that there is a positive correlation between the average monthly temperatures for Sao Paulo and Rio de Janeiro.\n\nLet’s assume that we also wanted to explore average temperature over time. In this case, a line plot would be a good choice. However, the data frame provides no single column which contains the monthly average temperatures.\nThe function pivot_longer() allows us to change the structure of the data frame by combining the columns JAN to DEC into a single column\n\nManaus_long &lt;- Manaus_raw %&gt;%\n  pivot_longer( cols=JAN:DEC, names_to=\"Month\" ) %&gt;%\n  rename( Temperature = value )\nslice_head( Manaus_long, n=3 )\n\n# A tibble: 3 × 3\n   YEAR Month Temperature\n  &lt;int&gt; &lt;chr&gt;       &lt;dbl&gt;\n1  1910 JAN          27.3\n2  1910 FEB          27  \n3  1910 MAR          26.5\n\n\nSo we have converted the original table to a narrower but substantially longer table with 3 columns; the pivot_longer() function by default stores the observed monthly averages in a column named value, which we renamed to Temperature.\nIf we wanted to reverse back to the original format, we would use the function pivot_wider(),\n\nManaus_wide &lt;- Manaus_long %&gt;% \n  pivot_wider( names_from=Month, values_from=Temperature )\n\nEach row in Manaus_long now corresponds to one month instead of one year. The one challenge that remains is to convert the variables YEAR and MONTH into a single variable that represents the date. There is unfortunately no easy way, but the following code does the job\n\n## Convert abbreviation for month into number\nManaus_long &lt;- \n  Manaus_long %&gt;% \n  mutate( Month = case_when( \n    Month == \"JAN\" ~ \"01\", Month == \"FEB\" ~ \"02\", Month == \"MAR\" ~ \"03\", \n    Month == \"APR\" ~ \"04\", Month == \"MAY\" ~ \"05\", Month == \"JUN\" ~ \"06\",\n    Month == \"JUL\" ~ \"07\", Month == \"AUG\" ~ \"08\", Month == \"SEP\" ~ \"09\", \n    Month == \"OCT\" ~ \"10\", Month == \"NOV\" ~ \"11\", Month == \"DEC\" ~ \"12\"\n    ) \n  )\n\n## Combine year and month and convert to date\nManaus_long &lt;- Manaus_long %&gt;%\n  mutate( Date = paste( Manaus_long$YEAR, Manaus_long$Month, sep=\"-\" ) ) %&gt;%\n  mutate( Date = ym( Date ) )\n\nFinally, we can create our line plot. We have to keep in mind that we still have entries of value 999.9 which we do not want to plot. We again replace values of 999.9 with \\(\\mathrm{\\texttt{NA}}\\):\n\nManaus_long %&gt;%\n  mutate( Temperature = na_if( Temperature, 999.9 ) ) %&gt;%\n  ggplot( aes(\"x\"=Date, \"y\"=Temperature) ) + \n  geom_line() + geom_smooth() +\n  labs( y=\"Average Monthly Temperature\") + theme_bw() +\n  theme( axis.title=element_text(size=16), axis.text=element_text(size=14) )\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\nAverage monthly temperature for Manaus, Brazil, between 1910 and 2019.\n\n\n\nThe plot indicates an increase in the average monthly temperature from about 27.5 to 29 degree Celsius over the time period.\nRemark: The last piece of code shows that we can use the pipe together with the functions from ggplot2.",
    "crumbs": [
      "Lecture Notes",
      "Data Visualization"
    ]
  },
  {
    "objectID": "lecture_notes/02-DataVisualization.html#summary",
    "href": "lecture_notes/02-DataVisualization.html#summary",
    "title": "Data Visualization",
    "section": "",
    "text": "We covered some of the principles regarding data visualization:\n\nWhen designing your data graphic, ensure that the main message/aspect is clearly visible and provide an interpretation of your plot. Avoid presenting plots that are not focused towards answering the research question.\nThe important types of graphics we use for data visualization and exploration are line plot, scatter plot, bar plot, histogram, density plot, box plot and violin plot.\n\nGraphics can be discussed in terms of four elements:\n\nVisual cues\nCoordinate system\nScale\nContext\n\n\nThe ggplot2 R package provides a wide range of tools for creating data graphics from a given data frame. This includes changing the coordinate system, the scale and selecting a wide range of types of graphics.\nFor complex data sets it is often useful to use facets and a wide range of visual cues. This may improve accessibility for the reader.\nIn practice we often have to restructure the data using the dplyr and tidyr packages before creating the data graphic.",
    "crumbs": [
      "Lecture Notes",
      "Data Visualization"
    ]
  },
  {
    "objectID": "practice/week_8/quiz_8.html",
    "href": "practice/week_8/quiz_8.html",
    "title": "MA22019 2025 - Quiz 8",
    "section": "",
    "text": "Overview\nThis week’s problem sheet focuses on the methods for analyzing spatial dependence introduced in Sections 4.3 and 4.4 in the lecture notes. Exercises 1-2 help you with revising the content of the lecture in Week 8.\nYou may want to load the following packages before starting the exercise:\n\nlibrary( dplyr )\nlibrary( lubridate )\nlibrary( ggplot2 )\nlibrary( tidyr )\nlibrary( sf )\nlibrary( ggspatial )\nlibrary( prettymapr )\nlibrary( sp )\nlibrary( gstat )\n\nWhen working on a University PC, you will have to first install some of these packages.\nExercise 1 - Exploring spatial structure in river flow data\nA data scientist used principal component analysis to explore the spatial structure / dependence in the daily maximum river flow values across 45 gauges in Northern England and the South of Scotland. They identified that the first 3 components explain more than 90% of the variation in the data and created the following plots representing the first three eigenvectors:\n\n\n\n\n\n\n\n\nProvide an interpretation for the three plots and then go to Moodle and complete the quiz.\nExercise 2 - Concentrations of zinc in the top soil\nThe file “Meuse.csv” gives topsoil zinc concentrations (in mg/kg) collected across 155 locations in a flood plain of the river Meuse. Specifically, we are given\n\nLon,Lat - Longitude and latitude coordinate of the locations\nZinc - Zinc concentration on logarithmic scale\n\nPerform the following steps to explore the spatial structure in the data:\n\nVisualize the zinc concentration on logarithmic scale using the ggspatial package. What do you conclude?\nExplore the spatial dependence in the zinc concentration on logarithmic scale by estimating the semi-variogram for the data. Go to Moodle and answer the quiz."
  }
]