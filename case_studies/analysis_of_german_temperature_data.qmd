---
title: "Analysis of German Temperature Data"
author: "Christian Rohrbeck"
date: "19/03/2023"
format: html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
library( dplyr )
library( ggplot2 )
library( sf )
library( ggspatial )
library( prettymapr )
```

## Loading the data and a first plot

The data are stored in the file "Temperature Germany.csv"

```{r}
Temperature <- read.csv("data/temperature_germany.csv" )  
```

The data provides spatial locations and maximum daily temperature:

```{r}
glimpse( Temperature )
```

# Visualization of the data

## Visualization using ggplot2 only

Use colour as a visual cue for the temperature values and longitude and latitude for the x and y axis respectively:

```{r, fig.align='center', fig.height=3, fig.width=4.5, out.width='50%'}
ggplot( Temperature, aes(x=longitude, y=latitude) ) +
  geom_point( aes(color=max.temp), size=1.2 ) + theme_bw() + 
  scale_color_distiller( palette="Reds", trans="reverse" ) +
  labs( x="Longitude", y="Latitude", color="Temperature")
```

## Importing and plotting shapefiles

We load the shapefile with the read_sf() function

```{r}
Germany <- read_sf( "data/gadm41_DEU_1.shp" )
```

Let's slightly reduce the complexity of the shape

```{r}
Germany <- Germany %>% st_simplify( dTolerance = 2000 )
```

We can plot the shape with

```{r, fig.align='center', fig.height=4, out.width='70%'}
ggplot( Germany ) + geom_sf() + theme_bw() + 
  labs( x="Longitude", y="Latitude" )
```

Time to combine the shapefile with the points 

```{r, fig.align='center', fig.height=4, out.width='70%'}
ggplot( Germany ) + geom_sf() + 
  geom_point( data=Temperature, aes(x=longitude, y=latitude,
                                    color=max.temp), size=2 ) + 
  scale_color_distiller( palette="Reds", trans="reverse" ) +
  theme_bw() + labs( x="Longitude", y="Latitude", color="Temperature" )
```

## Projections 

Let's apply a projection to the shapefile

```{r, fig.align='center', fig.height=4, out.width='70%'}
ggplot( Germany ) + theme_bw() + geom_sf() + 
  coord_sf( crs=st_crs(3346) )
```

We can also store the projected shapefile

```{r}
Germany_projected <- st_transform( Germany, crs = 3346 )
```

We also need to change the projection of the points if we wanted to plot on the projected surface. So we first convert them into a spatial object:

```{r}
Temperature_projected <- st_as_sf( Temperature, coords=c("longitude", "latitude"), crs="WGS84" )
```

Now we are ready to plot the points

```{r, fig.align='center', fig.height=4, out.width='70%'}
ggplot( Germany_projected ) + theme_bw() + geom_sf() +  
  geom_sf( data=Temperature_projected, aes(color=max.temp), size=2 ) + 
  scale_color_distiller( palette="Reds", trans="reverse" ) +
  theme_bw() + labs( x="Longitude", y="Latitude", color="Temperature" )
```

You will see another example in Tutorial Question 2 on Problem Sheet 6.

## Adding maps

An alternative to shapefiles is to use maps. We will use ggspatial for this:

```{r, fig.align='center', fig.height=4, out.width='70%', message=FALSE}
ggplot( Temperature, aes(x=longitude, y=latitude) ) +
  annotation_map_tile() +
  geom_spatial_point( aes(color=max.temp), size=2 ) + 
  scale_color_distiller( palette="Reds", trans="reverse" ) +
  theme_bw() + labs( x="Longitude", y="Latitude", color="Temperature" )
```


# Inverse distance weighting

## Function to perform inverse distance weighting

```{r}
IDW <- function( X, S, s_star, p){
  d <- sqrt( (S[,1]-s_star[1])^2 + (S[,2]-s_star[2])^2 )
  w <- d^(-p)
  if( min(d) > 0 )
    return( sum( X * w ) / sum( w ) )
  else 
    return( X[d==0] )
}
```

## Combine observations to define matrix for S

```{r}
coord <- cbind( Temperature$longitude, Temperature$latitude )
IDW( X=Temperature$max.temp, S=coord, s_star= c( 13.1, 51.0 ), p=5 )
```

## Estimate values over a grid

### Define the grid

```{r}
points_lat <- seq( 47.1, 55.1, by=0.05 )
points_lon <- seq( 5.8, 15.6, by=0.05 )
pixels <- as.matrix( expand.grid( points_lon, points_lat ) )
```


### Calculate values for difference choices of the power parameter 

```{r}
p05 <- p2 <- p20 <- c()
for( j in 1:length(pixels[,1]) ){
  p05[j] <- IDW( X=Temperature$max.temp, S=coord, s_star=pixels[j,], p=0.5 )
  p2[j]  <- IDW( X=Temperature$max.temp, S=coord, s_star=pixels[j,], p=2.0 )
  p20[j] <- IDW( X=Temperature$max.temp, S=coord, s_star=pixels[j,], p=20  )
}
```

## Visualize grid of predicted values


### Set up data frame

```{r}
library(tidyr)
Predict <- data.frame( "Lon"=pixels[,1], "Lat"=pixels[,2], 
                       "p0.5"=p05, "p2"=p2, "p20"=p20 )
Predict <- Predict %>% pivot_longer( cols=p0.5:p20, names_to = "Power" )
Predict <- Predict %>% 
  mutate( Power = case_when( Power == "p0.5" ~ "p=0.5", Power == "p2" ~ "p=2.0",
                             .default = "p=20" ) )
```

### Visualize predictions together with a map

```{r, fig.align='center', out.width='100%', fig.height=4, fig.width=10}
ggplot( data=Predict ) + theme_bw() +
  geom_raster( aes( x=Lon, y=Lat, fill=value ) ) + 
  facet_wrap( ~Power ) + 
  scale_fill_distiller( palette="Reds", trans="reverse" ) +
  geom_sf( data=Germany, alpha=0.0, color="white" ) +
  geom_point( data=Temperature, aes(x=longitude, y=latitude) ) + 
  labs( fill="Â°C", x="Longitude", y="Latitude" )
```
